---
title: "Rbootcamp"
author: "Michael Kleinsasser"
date: "8/8/2019"
output: 
    beamer_presentation:
      theme: "CambridgeUS"
      colortheme: "dolphin"
      fonttheme: "structurebold"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


## Mike's Personal Introduction

\begin{columns}[T] % align columns
\begin{column}{.48\textwidth}

\begin{itemize}
\setlength\itemsep{1em}

\item R programmer for the Department of Biostatistics

\item Write and mantain R packages for faculty and students

\item Consult faculty and students on writing R packages, optimization

\end{itemize}


\end{column}%
\hfill%
\begin{column}{.48\textwidth}

\includegraphics[width = 2in]{personal_picture.jpg}

\end{column}%
\end{columns}


## Rbootcamp Introduction

Goals:

- R basics: syntax, common functions, etc., via Rstudio
- R functions and for loops (functions and advanced control structures)
- Basics of R on the cluster (non-interactive R using BATCH scripts)
- Simulation analysis with comment on efficiency

## Materials

- All bootcamp materials online at https://github.com/umich-biostatistcs/Rbootcamp

  - Handouts for each topic with examples to work through

  - R scripts of our examples

- Go to link and download zip archive, extract

## Setup

Go to Rstudio cloud to follow along:

- Enter username, etc. for free account

- Follow along by typing commands in my slides

- If you have Rstudio/R, open that

- Recommended: Install R/Rstudio for days 2, 3

- See course materials for download instructions

## R Basics: Big Picture

 - R is a sophisticated calculator for statistics

Chambers (2016) Extending R:

 - Everything that exists in R is an object
 - Everything that happens in R is a function call
 
Obtain a basic working knowledge of R objects and functions, 

 - Google the rest
 
## R Basics: a basic schematic view

\includegraphics[width = 4.5in]{R_schemtic.JPG}

## R Basics: Goals

- Data types and functions
\smallskip 
  - Create object having data types
  - Combine those into data structures
  - Write basic R function

\medskip

- Learn parts of R most useful to statisticians
\smallskip 
  - How do most modeling functions work in R, and
  - How to inspect structure and content of objects
  
\medskip

- Apply knowledge to simulation
\smallskip 
  - How do most modeling functions work in R, and
  - How to inspect structure and content of objects
  
## Use R as a calculator

Standard operations: 

```{r , echo = TRUE}
# multiply *, divide /, add + subtract - 
18056.983 - 1005.118 + 22.53

( (pi - 3.14) / (3.14) )  * 100
```

\includegraphics[width = 2in]{calculator.JPG}


## Operators: arithmetic and logical

\begin{columns}[T] % align columns
\begin{column}{.48\textwidth}

\begin{table}
\begin{tabular}{l | l}
Operator & Description \\
\hline \hline
$+$ & addition \\ 
$-$ & subtraction \\ 
$/$ & division \\ 
\string^ & exponential \\ 
\%\% & modulus (x mod y) \\ 
\%/\% & integer division
\end{tabular}
\caption{Arithmetic Operators}
\end{table}


\end{column}%
\hfill%
\begin{column}{.48\textwidth}

\begin{table}
\begin{tabular}{l | l}
Operator & Description \\
\hline \hline
< & less than \\ 
<= & less than or equal \\
\string> & greater than \\
\string>= & greater than or equal \\
== & exactly equal to \\
!= & not equal to \\
!x & not x (x logical) \\
x|y & x OR y \\
x\&y & x AND y \\
isTRUE(x) & is x TRUE 
\end{tabular}
\caption{Logical Operators}
\end{table}

\end{column}%
\end{columns}


## Operators: an example

Test if these two expressions are equivalent in R:

```{r, echo=TRUE}
# Expression 1:


# Expression 2: 


# test equality:

```

## Operators and vectorization

Arithmetic/logical operators are \textbf{vectorized}:

Given these vectors:
```{r, eval=TRUE}
x = c(1,2,3); y = c(4,8,16) #; emp = c(T,F,F,T); ret = c(T,T,T,F)
x; y; # emp; ret
```

```{r, echo=TRUE}
x + y
x * y
y <= x
```



## Create, list, delete objects

Create object with "assign" operator

 - arrow then minus sign  <-
 - single equal sign      =

```{r asignment, echo = TRUE}
# x gets the number 3.14
x <- 3.14
x     # print x

# equivalently
x = 3.14
x     # print x
```


## Create, list, delete objects

Objects we create are stored in memory, e.g.:

```{r, echo = TRUE}
name = "Carmen"
n1 = 10
n2 = 100
m = 0.5
```


Use ls() function to list all objects in memory:

```{r, echo = TRUE}
ls()
```

Notice: I created x before, it's still in memory.

## Create, list, delete objects

Use ls() function to list all objects in memory:

```{r, echo = TRUE}
ls()
```

The function ls.str() displays some details about objects in memory:

```{r,echo=TRUE}
ls.str()
```

## Create, list, delete objects

To delete objects in memory, use rm() function

```{r, echo = TRUE}
rm(x) # delets object named x
ls()  # which objects remain in memory?
rm(m, n2, name) # remove multiple objects
ls()
rm(list = ls()) # remove everything from memory
ls()
```

## The on-line help

R has structured help pages providing "how-to"

 - \textbf{Description:} what function does
 - \textbf{Usage:} name with arguments and options
 - \textbf{Arguments:} how each argument should be structured
 - \textbf{Details:} more detailed description
 - \textbf{Value:} How the output is structured/ what it contains
 - \textbf{Examples:} examples of the function in use
 
```{r, echo = TRUE, eval = FALSE}
?rm          # help documentation for rm function
help("rm")   # alternately
```

## The on-line help

\includegraphics[width = 4in]{help_doc.JPG}

## Other R help

Many package writers create Vignettes and READMEs

How to view vignettes?

```{r, echo = TRUE, eval = FALSE}
vignette(all = TRUE) # list vignettes for installed packages
vignette(all = FALSE)  # vignettes from attached packages
```


How to view READMEs?

Other help...

## Objects in R

Objects (data, model output, functions)

 - Characterized by their \textbf{names} and \textbf{content}
 
 - attributes - specify the kind of data represented
    - e.g. mode, length
    
```{r, echo=TRUE}
x = 1
mode(x)
length(x)
```


## Basic data "modes" in R

The mode is the basic type of the elements of an object

The four main modes:

- numeric, comes in two flavors: integer, numeric
- character
- logical 
- complex

\small
```{r, echo=TRUE}
num = 15.533; name = "Mike"; isStudent = TRUE
```

```{r, echo=TRUE}
mode(num); mode(name); mode(isStudent)
```


## Atomic vectors

Fundamental data structure in R: 

- atomic vector - vector in which every element is of same mode

To create an atomic vector, use c() function:

```{r, echo=TRUE}
c(3.145, 2.18, 9.98e3, 0.05)
```

Example: create empty character vector of length 3 and story your full name

```{r, echo=TRUE}
vector(mode = "character", length = 3)
```


## Data types examples

3 ways to create numeric vector:

```{r , echo = TRUE}
# empty numeric vector
y1 <- numeric(6)
y1     # print y1

y2 <- vector(mode = "numeric", length = 6)
y2     # print y2

y3 <- c(5, 13.222, 2, 0.001, 77.4, 31.9)
y3     # print y3
```


## Objects in R: NA

NA means "Not Available" and it denotes missing data

(Insert after atomic vectors introduced)
\small
```{r, echo=TRUE}
c(3, 5, 9, NA, 18, 25, NA)  
```


## R data types/structures

Four fundamental data types:

- character, numeric (numeric or integer), logical, complex

Combine to form data structures

- atomic vector (atomic - vector of single type)
- list
- matrix
- data.frame
- factor

We will focus on matrices and data.frames

## Matrices

Matrices are the natural extension of atomic vectors into 2 dimensions

- any mode can be used, but numeric most common:

Syntax:

```{r, echo = TRUE,eval=FALSE}
m = matrix(data, nrow, ncol, byrow, dimnames)
```

- \textbf{data} is the input vector which becomes the data elements of the matrix
- \textbf{nrow, ncol} is the number of rows/columns to be created
- \textbf{byrow} is a logical clue. If TRUE then the input vector elements are arranged by row
- \textbf{dimnames} is the names assigned to the rows and columns

## Matrix examples:

Identity matrix:
```{r,echo=TRUE, eval=TRUE}
dat = c(1,0,0,0,1,0,0,0,1)  # data
iden = matrix(data = dat, nrow = 3, byrow = T)
iden  # print matrix
```

Easier:
```{r, echo=TRUE, eval=FALSE}
iden = diag(rep(1,3))
iden
```

## access elements of a matrix

- single brackets used to access elements

Access individual elements:

```{r, echo=TRUE}
# 2x5 matrix of numbers 1 to 10
P = matrix(data = 1:10, nrow = 2)  
P[1,3] # row 1, column 3
P[nrow(P),ncol(P)] # row 2, column 5 (bottom right position)
```

Access entire rows/columns:

```{r, echo=TRUE}
P[,3];
```

## The data.frame

The \textbf{data.frame} is the most common way to store and work with data in R

 - Not surprising: they are designed for this purpose

 - Most modeling functions work on data.frames

Composed of a list of equal length atomic vectors (can be of any type)

Example: 

\small The following are data on students in the class:

- \small Has Master's (logical):  TRUE FALSE FALSE TRUE
- \small GPA (numeric):           3.1  4.0   2.9   3.6
- \small First Name (character):  Mike Dan   Sara  Karen

Convert to three atomic vectors of appropriate type.

## data.frame examples

\small Create a data.frame out of the following "class" data:

- \small Has Master's (logical):  TRUE FALSE FALSE TRUE
- \small GPA (numeric):           3.1  4.0   2.9   3.6
- \small First Name (character):  Mike Dan   Sara  Karen

```{r , echo = TRUE}
# store data
has_ms <- c(TRUE, FALSE, FALSE, TRUE)
gpa <- c(3.1, 4.0, 2.9, 3.6)
name <- c("Mike", "Dan", "Sara", "Karen")
# Create data.frame
dat <- data.frame(has_MS = has_ms, GPA = gpa, Name = name)
dat    # print data.frame
```


## access elements of a data.frame

Each vector of a data.frame contains the values of a variable

Access each vector with the dollar sign $

Ex: Extract the GPA column and print it

```{r, echo=TRUE, eval=TRUE}
dat$GPA
```

Another example: ToothGrowth data.

```{r, echo=TRUE}
ToothGrowth$len
```


## data.frame

Preview head (first few rows) of data.frame:

```{r, echo=TRUE, eval=TRUE}
head(ToothGrowth)
```


View tail of data.frame:

```{r, echo=TRUE, eval=FALSE}
tail(dat)
```

View entire data.frame in new window:

```{r, echo=TRUE, eval=FALSE}
View(ToothGrowth)
```


## Inspect an object

- class() - what kind of object is it (high-level)?
\bigskip
- typeof() - what is the data type (low-level)?
\bigskip
- length() - how long is it?
\bigskip
- attributes() - does it have meta-data?
\bigskip

## Inspect an object

- class() - what kind of object is it (high-level)?
```{r, echo=TRUE}
class(ToothGrowth)
```
\bigskip
- typeof() - what is the data type (low-level)?
```{r, echo=TRUE}
typeof(ToothGrowth$supp)
```


## Inspect an object

- length() - how long is it?
```{r, echo=TRUE}
length(ToothGrowth$dose)
```
\medskip
- attributes() - does it have meta-data?
```{r, echo=TRUE}
attributes(ToothGrowth)
```


## R functions

\small R function syntax:

\small NAME <- function(ARG1, ARG2, ARG3) { \newline
\small \hspace*{20pt} DO SOMETHING \newline
\small \hspace*{20pt} STORE RESULT \newline
\small \hspace*{20pt} return(RESULT) \newline
\small }

```{r , echo = TRUE}
pow <- function(base, expon) { # power function
  prod(rep(base, expon)) # base^(expon)
}
# Use power function
pow(5, 2)
pow(10, 3)
```

## Common R functions

\small R has a huge collection of packages:

\small  - 6,000+ packages for data analysis build (on CRAN alone)

\small Example: lm (linear models)

\small - Use ?lm to read help documentation 

\includegraphics[width = 3in]{lm_help.PNG}

## Fit a linear model with lm

- Use built-in data set ToothGrowth

- ?ToothGrowth for help:

\includegraphics[width = 3in]{quesToothGrowth.JPG}

## View the data

\small View data in new window:
```{r, echo = TRUE,eval=FALSE}
View(ToothGrowth)
```
\bigskip
\small Or use head to view only first 6 rows:
\tiny
```{r, echo = TRUE}
head(ToothGrowth)
```
\bigskip
\small How big is the data?
\tiny
```{r, echo = TRUE}
dim(ToothGrowth)
```


## Using lm() function for linear models
Call lm on the data and formula, store result "lm" object:
```{r, echo = TRUE, eval = TRUE}
tooth_fit = lm(formula = len ~ supp + dose, 
               data = ToothGrowth)
```

Formulas in R:
```{r, echo = TRUE, eval = FALSE}
len ~      # Response column name, ~ for "="
  supp +   # First predictor name + for "+"
  dose     # second predictor name
```

Many R functions use the formula argument.

## Getting detailed information

\small
Basic "print" of model:
\tiny
```{r, echo = TRUE, eval = TRUE}
print(tooth_fit)     # equivalent to tooth_fit
```
\small
Detailed summary:
\tiny
```{r, echo = TRUE, eval = TRUE}
summary(tooth_fit)
```

## Understanding R classes

- What is this thing?
```{r, echo = TRUE, eval = FALSE}
class(tooth_fit)
```
- What are the methods for this object?
```{r, echo = TRUE, eval = FALSE}
methods(class = "lm")
```
- What is its structure? (i.e., what's in it)
```{r, echo = TRUE, eval = FALSE}
str(tooth_fit)
```

## Understanding R classes

- What is this thing?
```{r, echo = TRUE, eval = TRUE}
class(tooth_fit)
```

## Understanding R classes
\small
- What are the methods for this object?
```{r, echo = TRUE, eval = TRUE}
methods(class = "lm")
```

## Understanding R classes

\tiny
- What is its structure? (i.e., what's in it)
```{r, echo = TRUE, eval = TRUE}
str(tooth_fit)
```

## Understanding R classes

- Pull something out of the "lm" fit object:

\tiny
```{r, echo = TRUE, eval = TRUE}
tooth_fit$fitted.values        # y_hat's for the linear model
```

## Extracting data from model objects

Some generic extraction methods: 

```{r, echo = TRUE, eval = FALSE}
coef(tooth_fit)            # model coefficients

coef(summary(tooth_fit))   # adds test statistics, p-values

vcov(tooth_fit)            # variance/covariance matrix
```

Note: depending on implementation, these may not be available
- Check methods with "methods(object)" before attempting

## Extracting data from model objects (in detail)

Extract coefficients, test stats, and p-values
```{r, echo = TRUE, eval = TRUE}
coef(summary(tooth_fit))   # adds test statistics, p-values
```


## Predict new values

- predict() function is generic and works with many models

- Pass in a new data.frame with the same column names:

```{r, echo = TRUE, eval = TRUE}
to_predict = data.frame(dose = 0.5, supp = "VC")
```

```{r, echo = TRUE, eval = TRUE}
predict(tooth_fit, newdata = to_predict)
```


## Predict new values (example 2)

- predict() function is generic and works with many models

- Pass in a new data.frame with the same column names:

\small
```{r, echo = TRUE, eval = TRUE}
to_predict = data.frame(dose = seq(0,1,0.1), supp = "OJ")
```

```{r, echo = TRUE, eval = TRUE}
predict(tooth_fit, newdata = to_predict)
```


## R on cluster (non-interactive R)

\textbf{Cluster Computation}

- Dan Barker danbarke at umich.edu

\medskip

- Cluster System Administrator


## R workflow for statistical analysis

\begin{columns}[T] % align columns
\begin{column}{.36\textwidth}

\begin{itemize}
\setlength\itemsep{1em}

\item Bootcamps throughout semester on each area


\end{itemize}


\end{column}%
\hfill%
\begin{column}{.62\textwidth}

\includegraphics[width = 3in]{analysis_in_r2.png}

\end{column}%
\end{columns}

## Advanced control structures

Common misconception: "loops in R are slow"

Explain

## Loops: often not necessary

 - Many R functions are "vectorized" (vector in, vector out)

 - While most other languages require loops, R does not:
 
```{r, echo = TRUE, eval = TRUE}
a = c(5, 2, 4, 12, 1)
b = c(2, 0, 3, -1, 2)

a + b     # vector + vector = vector
```

Takehome: When possible, operate on vectors and matrices, don't loop over each 
row/position index

## Problem: not all functions are vectorized

- Some functions, like read.table() for reading a table of data into R, are 
not vectorized

- But what if we have a list of files to read in? "data1.txt", "data2.txt",
"data3.txt", ..., "data50.txt"

```{r, echo = TRUE, eval = TRUE, results='hide'}
   # the 50 data set names
file_names = paste0("data", 1:50, ".txt")  
```

Attempt it, will cause error:
```{r, echo = TRUE, eval = FALSE}
read.table(file_names)  # error!
```


## map() from purrr package to avoid loop

- map() allows you to apply a function to each element of a vector

- faster, easier to read than a loop

```{r, echo = TRUE, eval = FALSE}
read.table(file_names)  # error!
```

```{r, echo = TRUE, eval = FALSE}
    # list of 50 data sets
my_dat_list = map(file_names, read.table)
    # results from reading data1.txt
my_dat_list[[1]]     
    # results from reading data50.txt
my_dat_list[[50]]       
```

## Create your own functions for map

Generate random samples from a Normal with different variances

```{r, echo = TRUE, eval = FALSE}
draws = map(2:20, function(x) rnorm(25, mean=0, sd=x))
# returns a list with vectors of draws

# first vector of draws:
draws[[1]]

# last vector of draws:
draws[[19]]
```

## Create your own functions for map

Now, estimate the standard error:

```{r, echo = TRUE, eval = FALSE}
map(draws, sd)  # sd() is standard deviation in R
map_dbl(draws, sd) # numeric vector
```

## For loop vs map() version

- Standard for loop:

```{r, echo = TRUE, eval = FALSE}

```

- map():

```{r, echo = TRUE, eval = FALSE}

```


## Sometimes loops are required

Sometime you just need loops:

- Growth model, new values depend on previous values

```{r, echo = TRUE, eval = FALSE}
N = 20
for (i in 2:30) {
  f = rpois(1, 0.15*N[i-1])   # births
  d = rbinom(1, N[i-1], 0.1)  # deaths
  N[i] = N[i-1] + f - d
}

plot(seq_along(N), N)
```

Show the plot!

## Problem: Growing object is slow

```{r, echo = TRUE, eval = FALSE}
N = 20
for (i in 2:30) {
  f = rpois(1, 0.15*N[i-1])   # births
  d = rbinom(1, N[i-1], 0.1)  # deaths
  N[i] = N[i-1] + f - d
}

plot(seq_along(N), N)
```

- Our growth model loop is slow because we are growing a vector at each iteration

- Solution pre-allocate vector (or any data type), then fill with loop

## Efficient memory usage 

Improved code:

```{r, echo = TRUE, eval = FALSE}
# Pre-allocate to correct size
N = vector(mode = "numeric", length = 30)
N[1] = 20
for (i in 2:30) {
  f = rpois(1, 0.15*N[i-1])   # births
  d = rbinom(1, N[i-1], 0.1)  # deaths
  N[i] = N[i-1] + f - d
}

plot(seq_along(N), N)
```


## overview of loops

- Although slow at times, writing code is a trade-off between time consumed by the programmer and time gained with efficient code

- Most times, loops are fast (enough) and convenient

- Strategy: Write a loop, then if slow, re-write

- Use vectorized functions whenever possible

- Map when function is not vectorized
  - Avoids the need to track indexes
  - Does the pre-allocation for you

- If you use loops, avoid growing lists/collections/data.frames
  - pre-allocate memory
  
  
## Simulation Basics

Why simulate?

  - confirm model/method works by mimicking the real world

Sampling in R from sets and distributions:

Simulate a coin toss experiment:

  - toss a coin ten times, record what side it lands on each time
  
\small
```{r, echo=TRUE}
set.seed(7794)
sample(c("H","T"), size = 10, replace = TRUE) # fair coin
sample(c("H","T"), size = 10, replace = TRUE, 
                         prob = c(0.6, 0.4)) # weighted coin
```

## Simulation Basics

Sampling in R from distributions:

 - d___(x) returns the density of a probability distribution for a discrete value of x
 
 - p___(q) returns the cumulative density function (CDF) up to q
 
 - q___(p) returns the quantile from a cumulative probability
 
 - r___(n) returns a random deviate (a simulation of random draw) of size n

\small
Example:
```{r, echo=TRUE}
qnorm(0.025); dnorm(0)
```

?distributions for more information

## Simulation

\begin{table}
\begin{tabular}{l | l}
distribution & function \\
\hline \hline
Normal & norm(n, mean=0, sd=1) \\ 
exponential & exp(n, rate=1) \\ 
uniform & unif(n, min=0, max=1) \\
gamma & gamma(n, shape, scale=1) \\ 
poisson & pois(n, lambda) \\
Weibull & weibull(n, shape, scale=1) \\
Cauchy & cauchy(n, location=0, scale=1) \\
beta & beta(n, shape1, shape2) \\
Student t & t(n, df) \\
binomial & binom(n, size, prob) \\
logistic & logis(n, location=0, scale=1)
\end{tabular}
\caption{Built-in distributions}
\end{table}

## Simulation: sample from probability distributions

```{r, echo=TRUE, eval=FALSE}
rnorm(6) # 6 standard normal deviates
rnorm(10, mean=50, sd=19) # set mean and spread
runif(10, min=0, max=1) # uniform distribution
rpois(10, lambda=15) # Poisson 
```
\bigskip
Cointoss reframed: toss coin 8 times using binomial distribution

```{r, echo=TRUE, eval=FALSE}
set.seed(7794)
rbinom(8, size=1, p=0.5) # 8 coin tosses
```

## Some simple simulations 

Problem: predict the number of girls in 400 births in a population where prob.
of female birth is 48.8%

```{r, echo=TRUE}
#set.seed()
n.girls = rbinom(n=1, size=400, prob=0.488)
n.girls
```

 - Get a distribution of the number of female births when prob. = 0.488
 
```{r, echo=TRUE, eval=FALSE}
n.sims=1000
n.girls=rbinom(n.sims,400,0.488)
hist(n.girls)
```
 

## Simulation: Confidence intervals

Open simulations.R script in course files

\bigskip

Exercise: Is the coverage rate of confidence intervals for the mean accurate?

 - Given conditions similar to ours, does our method for generating confidence intervals capture the true value 95% of the time?

\includegraphics[width = 3in]{CI_coverage_example.JPG}

## Replicate for repeating simulations

Function to simulate the mean of 100 standard normal draws:

```{r, echo=TRUE, eval=FALSE}
sim.mean = function() { mean(rnorm(100)) }
```
\medskip
The following for loop repeats the simulation 1,000 times:

```{r, echo=TRUE, eval=FALSE}
sims = vector(mode = "numeric", length = 1000L)
for(i in 1:1000) { sims[i] = sim.mean() }
```
\medskip
We can avoid the for loop with \textbf{replicate()}:

```{r, echo=TRUE, eval=FALSE}
sims = replicate(1000, sim.mean())
```


## Simulate lm 

Simulate a linear model with two predictors, and then use lm in R to see
if we recovered the values

Plot

## Bootstrap lm results



## Useful R packages

What about working with data and plotting in R?
\medskip

- Don't bother with base R, learn these:

\medskip
- ggplot2 - Best package for plotting data
  - getting started: 
  
\medskip
- dplyr - Best package for manipulating/processing data
  - getting started:
  
  
## Future bootcamps 

- dplyr: date ____

- ggplot2: date ____
